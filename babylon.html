<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Babylon - Getting Started</title>
    <!--- link to the last version of babylon --->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        #renderCanvas {
            width   : 100%;
            height  : 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
      var scene = null;
      var engine = null;
      var canvas = document.querySelector('#renderCanvas');
      var box = null;
      var velocity = new BABYLON.Vector3.Zero(); // not moving
      var rotation = new BABYLON.Vector3.Zero(); // not rotating

      function createEngine() {
        // load the 3D engine
        var eng = new BABYLON.Engine(canvas, true);

        return eng;
      }

      // createScene function that creates and return the scene
      function createScene(engine) {
        // create a basic BJS Scene object
        var scn = new BABYLON.Scene(engine);

        var map = {}; //object for multiple key presses
        scn.actionManager = new BABYLON.ActionManager(scn);
        scn.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
          map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
        }));
        scn.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
          map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
        }));

        // create a ArcRotateCamera, and set its position to (x:0, y:0, z:-10)
        var camera = new BABYLON.ArcRotateCamera('Camera', 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scn);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.setPosition(new BABYLON.Vector3(0, 0, -10));
        // attach the camera to the canvas
        camera.attachControl(canvas, false);

        // create a basic light, aiming 0,1,0 - meaning, to the sky
        var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,1,0), scn);

        // parent object used to simplify control and collisions
        box = BABYLON.MeshBuilder.CreateBox('ship', {size:1}, scn);
        box.isVisible = false;
        createShip(box, scn);

        scn.registerAfterRender(function () {
          var rotThrust = 0.001;
          var matrix = box.getWorldMatrix();
          var vector = new BABYLON.Vector3.Zero();
          // positional changes
          if (map["q"]) { // forward thrust
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, 1), matrix);
            map["q"] = undefined;
          };
          if (map["a"]) { // reverse thrust
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, -1), matrix);
            map["a"] = undefined;
          };
          if (map["s"]) { // strafe left
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(-1, 0, 0), matrix);
            map["s"] = undefined;
          };
          if (map["f"]) { // strafe right
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(1, 0, 0), matrix);
            map["f"] = undefined;
          };
          if (map["e"]) { // upward thrust
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 1, 0), matrix);
            map["e"] = undefined;
          }
          if (map["d"]) { // downward thrust
            vector = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, -1, 0), matrix);
            map["d"] = undefined;
          }
          if (map["\\"]) { // zero out thrust (all stop)
            velocity.x = 0;
            velocity.y = 0;
            velocity.z = 0;
          }
          velocity.addInPlace(vector);

          // rotational changes
          if (map["i"]) { // up arrow (pitch down)
            rotation.x += rotThrust;
          }
          if (map["k"]) { // down arrow (pitch up)
            rotation.x -= rotThrust;
          }
          if (map["j"]) { // left arrow (roll left)
            rotation.z += rotThrust;
          }
          if (map["l"]) { // right arrow (roll right)
            rotation.z -= rotThrust;
          }
          if (map["u"]) { // left arrow (yaw left)
            rotation.y -= rotThrust;
          }
          if (map["o"]) { // right arrow (yaw right)
            rotation.y += rotThrust;
          }
          if (map["/"]) { // zero out rotation (all stop)
            rotation.x = 0;
            rotation.y = 0;
            rotation.z = 0;
          }
        });

        // return the created scn
        return scn;
      }

      function createShip(parent, scene) {
        // ship body
        var cylinderOpts = {
          height: 1,
          diameterTop: 0,
          diameterBottom: 1,
          tessellation: 6
        };
        var body = BABYLON.MeshBuilder.CreateCylinder("ship body", cylinderOpts, scene);
        body.addRotation(Math.PI / 4, 0, 0); // = new BABYLON.Vector3(Math.PI / 4, 0, 0);
        body.bakeTransformIntoVertices(body.getWorldMatrix());
        body.position = new BABYLON.Vector3(0, 0, 0.5);
        body.parent = parent;

        // cockpit
        var sphereOpts = {
          segments: 3,
          diameter: 0.5
        };
        var cockpit = BABYLON.MeshBuilder.CreateSphere("ship cockpit", sphereOpts, scene);
        cockpit.position = new BABYLON.Vector3(0, 0.125, 0.25);
        cockpit.bakeTransformIntoVertices(cockpit.getWorldMatrix());
        cockpit.parent = parent;

        createShipAxisLines(parent, scene);
      }

      function createShipAxisLines(parent, scene) {
        var size = 1;
        var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0); // red
        axisX.parent = parent;
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0); // green
        axisY.parent = parent;
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1); // blue
        axisZ.parent = parent;
      }

      function translateMesh(mesh, worldVelocity) {
        if (mesh) {
          var dirThrust = 0.001;
          mesh.translate(worldVelocity, dirThrust, BABYLON.Space.WORLD);
        }
      }

      function rotateMesh(mesh, localRotation) {
        if (mesh) {
          mesh.addRotation(localRotation.x, localRotation.y, localRotation.z);
        }
      }

      window.addEventListener('DOMContentLoaded', function() {
        if (!engine) {
          engine = createEngine();
        }
        if (!scene) {
          scene = createScene(engine);
        }

        // run the render loop
        engine.runRenderLoop(function(){
          translateMesh(box, velocity);
          rotateMesh(box, rotation);
          scene.render();
        });
      });

      window.addEventListener('resize', function() {
        if (engine) {
          engine.resize();
        }
      });
    </script>
</body>
</html>
